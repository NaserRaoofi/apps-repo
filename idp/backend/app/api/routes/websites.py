import hashlib
import os
import uuid
from datetime import datetime

import yaml
from app.database import get_db
from app.database.models import (
    DatabaseTypeEnum,
    ResourcePlanEnum,
    Website,
    WebsiteStatusEnum,
    WebsiteTypeEnum,
)
from app.models.job import JobResponse, JobStatus, JobType
from app.models.website import (
    ResourcePlanInfo,
    ResourcePlansResponse,
    WebsiteCreateRequest,
    WebsiteListResponse,
    WebsiteResponse,
)
from app.services.github_service import github_service
from fastapi import APIRouter, BackgroundTasks, Depends, HTTPException, Query
from sqlalchemy.orm import Session

router = APIRouter()

# Resource plans configuration
RESOURCE_PLANS = {
    "basic": ResourcePlanInfo(
        name="Basic",
        cpu_request="100m",
        cpu_limit="200m",
        memory_request="256Mi",
        memory_limit="512Mi",
        storage="1Gi",
        description="Perfect for small websites and blogs",
    ),
    "standard": ResourcePlanInfo(
        name="Standard",
        cpu_request="250m",
        cpu_limit="500m",
        memory_request="512Mi",
        memory_limit="1Gi",
        storage="5Gi",
        description="Ideal for business websites and small e-commerce",
    ),
    "premium": ResourcePlanInfo(
        name="Premium",
        cpu_request="500m",
        cpu_limit="1",
        memory_request="1Gi",
        memory_limit="2Gi",
        storage="20Gi",
        description="High-performance for large e-commerce and traffic",
    ),
}


def hash_password(password: str) -> str:
    """Hash password for storage."""
    return hashlib.sha256(password.encode()).hexdigest()


def create_helm_values_file(website: Website) -> str:
    """Create Helm values.yaml file for website deployment."""
    values = website.to_helm_values()

    # Create values directory structure inside the backend
    base_dir = "/home/sirwan/apps-repo/idp/backend"
    values_dir = f"{base_dir}/website-template/values"
    os.makedirs(values_dir, exist_ok=True)

    # Write values file with format: values-{website_id}.yaml
    values_filename = f"values-{website.website_id}.yaml"
    values_path = f"{values_dir}/{values_filename}"

    with open(values_path, "w") as f:
        # Add header comment with website information
        f.write(f"# Helm values for website: {website.website_id}\n")
        f.write(f"# Domain: {website.domain}\n")
        f.write(f"# Type: {website.website_type.value}\n")
        f.write(f"# Plan: {website.resource_plan.value}\n")
        f.write(f"# Generated: {website.created_at}\n")
        f.write("# Auto-generated by Website IDP - DO NOT EDIT MANUALLY\n\n")
        yaml.dump(values, f, default_flow_style=False, indent=2)

    print(f"Generated Helm values file: {values_path}")

    # Automatically push to GitHub
    try:
        github_result = github_service.auto_push_values(
            str(website.website_id), "created"
        )
        if github_result["success"]:
            msg = github_result["message"]
            print("✅ Successfully pushed to GitHub: " + msg)
        else:
            print(f"⚠️ GitHub push failed: {github_result['message']}")
            # Log the error but don't fail the website creation
    except Exception as e:
        print(f"⚠️ GitHub push error: {str(e)}")

    return values_path


@router.get("/resource-plans", response_model=ResourcePlansResponse)
async def get_resource_plans():
    """Get available resource plans."""
    return ResourcePlansResponse(plans=RESOURCE_PLANS)


@router.post("/", response_model=JobResponse)
async def create_website(
    request: WebsiteCreateRequest,
    background_tasks: BackgroundTasks,
    db: Session = Depends(get_db),
):
    """Create a new website deployment."""

    # Auto-generate missing fields from simplified frontend data
    website_id = request.subdomain  # Use subdomain as website ID
    domain = f"{request.subdomain}.naserraoofi.com"  # Generate full domain

    # Set default values for complex fields
    website_type = WebsiteTypeEnum.WORDPRESS
    cluster = "dev"
    resource_plan = ResourcePlanEnum.BASIC
    database_type = DatabaseTypeEnum.INTERNAL
    storage_class = "gp2"

    # Check if website_id already exists
    existing_website = (
        db.query(Website).filter(Website.website_id == website_id).first()
    )
    if existing_website:
        raise HTTPException(
            status_code=400,
            detail=f"Website with ID '{website_id}' already exists",
        )

    # Create new website record
    website = Website(
        website_id=website_id,
        domain=domain,
        website_type=website_type,
        cluster=cluster,
        resource_plan=resource_plan,
        database_type=database_type,
        storage_class=storage_class,
        admin_username=request.adminUsername,
        admin_password=hash_password(request.adminPassword),
        admin_email=request.adminEmail,
        blog_name=request.blogName,
        status=WebsiteStatusEnum.PENDING,
        namespace=f"{cluster}-{website_id}",
    )

    # Save to database
    db.add(website)
    db.commit()
    db.refresh(website)

    # Create job for background processing
    job_id = str(uuid.uuid4())
    job = JobResponse(
        id=job_id,
        job_type=JobType.WEBSITE_CREATE,
        status=JobStatus.PENDING,
        website_id=website_id,
        progress=0,
        logs=[f"Website '{website_id}' created in database"],
        created_at=datetime.utcnow(),
    )

    # Add background task to create Helm values and deploy
    background_tasks.add_task(process_website_creation, job_id, website.id, db)

    return job


async def process_website_creation(job_id: str, website_id: int, db: Session):
    """Background task to process website creation."""
    website = db.query(Website).filter(Website.id == website_id).first()
    if not website:
        return
    try:
        website.status = WebsiteStatusEnum.CREATING
        db.commit()
        create_helm_values_file(website)
        website.status = WebsiteStatusEnum.RUNNING
        website.deployed_at = datetime.utcnow()
        website.ingress_url = f"https://{website.domain}"
        db.commit()
    except Exception as exc:
        if website:
            website.status = WebsiteStatusEnum.FAILED
            db.commit()
        print("Error processing website creation: " + str(exc))
        return


@router.get("/", response_model=WebsiteListResponse)
async def list_websites(
    page: int = Query(1, ge=1),
    size: int = Query(10, ge=1, le=100),
    db: Session = Depends(get_db),
):
    """List all websites."""
    # Calculate offset
    offset = (page - 1) * size

    # Query websites with pagination
    websites_query = db.query(Website).offset(offset).limit(size)
    websites = websites_query.all()

    # Get total count
    total = db.query(Website).count()

    # Convert to response models
    website_responses = []
    for website in websites:
        website_responses.append(
            WebsiteResponse(
                id=str(website.id),
                website_id=str(website.website_id),
                domain=str(website.domain),
                resource_plan=website.resource_plan.value,
                website_type=website.website_type.value,
                status=website.status.value,
                created_at=website.created_at,
                updated_at=website.updated_at,
                deployed_at=website.deployed_at,
            )
        )

    return WebsiteListResponse(
        websites=website_responses, total=total, page=page, size=size
    )


@router.get("/{website_id}", response_model=WebsiteResponse)
async def get_website(website_id: str):
    """Get website details."""
    # TODO: Implement database query
    raise HTTPException(status_code=404, detail="Website not found")


@router.delete("/{website_id}", response_model=JobResponse)
async def delete_website(website_id: str, background_tasks: BackgroundTasks):
    """Delete a website deployment."""
    # TODO: Check if website exists

    # Create job
    job_id = str(uuid.uuid4())
    job = JobResponse(
        id=job_id,
        job_type=JobType.WEBSITE_DELETE,
        status=JobStatus.PENDING,
        website_id=website_id,
        progress=0,
        logs=[],
        created_at=datetime.utcnow(),
    )

    # TODO: Add job to queue
    # background_tasks.add_task(delete_website_task, job_id, website_id)

    return job


@router.get("/{website_id}/logs")
async def get_website_logs(website_id: str):
    """Get website deployment logs."""
    # TODO: Implement log retrieval from Kubernetes
    return {"logs": []}


@router.post("/{website_id}/restart", response_model=JobResponse)
async def restart_website(website_id: str, background_tasks: BackgroundTasks):
    """Restart website deployment."""
    # TODO: Implement restart logic
    job_id = str(uuid.uuid4())
    job = JobResponse(
        id=job_id,
        job_type=JobType.WEBSITE_UPDATE,
        status=JobStatus.PENDING,
        website_id=website_id,
        progress=0,
        logs=[],
        created_at=datetime.utcnow(),
    )

    return job
