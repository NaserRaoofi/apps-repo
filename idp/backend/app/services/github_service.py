"""
GitHub service for automatic repository operations.
Handles automatic commit and push of generated values files.

Enhancements:
- Directory watcher that auto-detects new values files.
- Target branch configurable via ENV IDP_VALUES_BRANCH (default main).
- Safe push to main using a temporary worktree to avoid merges.
"""

import os
import shutil
import subprocess
import threading
import time
from datetime import datetime
from pathlib import Path
from typing import List


class GitHubService:
    """Service for automatic GitHub operations."""

    def __init__(self, repo_path: str = "/home/sirwan/apps-repo"):
        self.repo_path = Path(repo_path)
        self.values_dir = (
            self.repo_path / "idp" / "backend" / "website-template" / "values"
        )
        self._watcher_thread: threading.Thread | None = None
        self._stop_event = threading.Event()
        self._known_files: set[str] = set()
        # Branch to push to (default main, override with ENV IDP_VALUES_BRANCH)
        self.target_branch = os.getenv("IDP_VALUES_BRANCH", "main")

    def git_command(self, cmd: List[str]) -> tuple[bool, str]:
        """Execute git command and return success status and output."""
        try:
            result = subprocess.run(
                ["git"] + cmd,
                cwd=self.repo_path,
                capture_output=True,
                text=True,
                check=True,
            )
            return True, result.stdout
        except subprocess.CalledProcessError as e:
            return False, f"Git command failed: {e.stderr}"
        except Exception as e:
            return False, f"Unexpected error: {str(e)}"

    def check_git_status(self) -> tuple[bool, List[str]]:
        """Check if there are any uncommitted changes."""
        success, output = self.git_command(["status", "--porcelain"])
        if not success:
            return False, []

        # Parse git status output to get list of changed files
        changed_files = []
        for line in output.strip().split("\n"):
            if line.strip():
                # Format: "XY filename" where X and Y are status codes
                changed_files.append(line[3:].strip())

        return True, changed_files

    def add_values_files(self) -> tuple[bool, str]:
        """Add all values files in the website-template directory."""
        values_pattern = "idp/backend/website-template/values/*.yaml"
        success, output = self.git_command(["add", values_pattern])
        return success, output

    def commit_values(
        self, website_id: str, action: str = "created"
    ) -> tuple[bool, str]:
        """Commit values files with descriptive message."""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        commit_message = (
            f"feat: {action} WordPress values for {website_id}\n\n"
            f"Auto-generated Bitnami WordPress Helm values\n"
            f"Website ID: {website_id}\n"
            f"Timestamp: {timestamp}\n"
            f"Generated by: Website IDP Backend"
        )

        success, output = self.git_command(["commit", "-m", commit_message])
        return success, output

    def get_current_branch(self) -> str:
        success, output = self.git_command(["rev-parse", "--abbrev-ref", "HEAD"])
        if success:
            return output.strip()
        return ""

    def push_to_remote(self, branch: str | None = None) -> tuple[bool, str]:
        """Push current branch to remote."""
        target = branch or self.target_branch
        return self.git_command(["push", "origin", target])

    # --- Safe push to main using worktree ---
    def _push_values_to_main_worktree(self, website_id: str) -> tuple[bool, str]:
        """Push only values files to main branch using a temporary worktree.

        This avoids merging the entire developer branch history into main.
        """
        temp_dir = self.repo_path / ".git" / "_values_worktree"
        # Clean up any previous failed attempt
        if temp_dir.exists():
            try:
                shutil.rmtree(temp_dir)
            except Exception:
                pass

        # Ensure we have latest main
        fetch_ok, _ = self.git_command(["fetch", "origin", "main"])
        if not fetch_ok:
            return False, "Failed to fetch origin/main"

        # Add worktree tracking origin/main (detached) with temp branch
        add_ok, add_out = self.git_command(
            [
                "worktree",
                "add",
                str(temp_dir),
                "-b",
                "_values_main_tmp",
                "origin/main",
            ]
        )
        if not add_ok:
            return False, f"Failed to add worktree: {add_out}"

        try:
            # Copy values files into worktree
            target_values_dir = (
                temp_dir / "idp" / "backend" / "website-template" / "values"
            )
            target_values_dir.mkdir(parents=True, exist_ok=True)
            for yf in self.values_dir.glob("values-*.yaml"):
                shutil.copy2(yf, target_values_dir / yf.name)

            # Stage only values files
            add_values_ok, add_values_out = self.git_command(
                [
                    "-C",
                    str(temp_dir),
                    "add",
                    "idp/backend/website-template/values/values-*.yaml",
                ]
            )
            if not add_values_ok:
                return False, f"Worktree add failed: {add_values_out}"

            # Check if there is anything to commit
            status_ok, status_out = self.git_command(
                [
                    "-C",
                    str(temp_dir),
                    "status",
                    "--porcelain",
                ]
            )
            if not status_ok:
                return False, "Worktree status failed"
            if not status_out.strip():
                return True, "No changes to commit on main"

            # Commit
            ts = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S")
            commit_ok, commit_out = self.git_command(
                [
                    "-C",
                    str(temp_dir),
                    "commit",
                    "-m",
                    (
                        "feat(values): add/update WordPress values for "
                        f"{website_id}\n\nWorktree commit at {ts}"
                    ),
                ]
            )
            if not commit_ok:
                return False, f"Worktree commit failed: {commit_out}"

            # Push to main
            push_ok, push_out = self.git_command(
                [
                    "-C",
                    str(temp_dir),
                    "push",
                    "origin",
                    "HEAD:main",
                ]
            )
            if not push_ok:
                return False, f"Worktree push failed: {push_out}"
            return True, "Pushed values to main via worktree"
        finally:
            # Remove worktree (force to avoid lingering)
            self.git_command(["worktree", "remove", "-f", str(temp_dir)])
            # Delete temp branch ref if created
            self.git_command(["branch", "-D", "_values_main_tmp"])  # cleanup

    def auto_push_values(self, website_id: str, action: str = "created") -> dict:
        """
        Automatically commit and push new values files.
        Returns status information about the operation.
        """
        result = {
            "success": False,
            "website_id": website_id,
            "action": action,
            "steps": {},
            "message": "",
        }

        # Step 1: Check git status
        status_success, changed_files = self.check_git_status()
        result["steps"]["check_status"] = {
            "success": status_success,
            "changed_files": changed_files,
        }

        if not status_success:
            result["message"] = "Failed to check git status"
            return result

        # Step 2: Add values files
        add_success, add_output = self.add_values_files()
        result["steps"]["add_files"] = {
            "success": add_success,
            "output": add_output,
        }

        if not add_success:
            result["message"] = f"Failed to add values files: {add_output}"
            return result

        # Step 3: Commit changes
        commit_success, commit_output = self.commit_values(website_id, action)
        result["steps"]["commit"] = {
            "success": commit_success,
            "output": commit_output,
        }

        if not commit_success:
            result["message"] = f"Failed to commit changes: {commit_output}"
            return result

        # Step 4: Push to target branch (special handling if target is main)
        current_branch = self.get_current_branch()
        if self.target_branch == "main" and current_branch != "main":
            push_success, push_output = self._push_values_to_main_worktree(website_id)
        else:
            push_success, push_output = self.push_to_remote()
        result["steps"]["push"] = {
            "success": push_success,
            "output": push_output,
        }

        if not push_success:
            result["message"] = f"Failed to push to remote: {push_output}"
            return result

        # Success!
        result["success"] = True
        result["message"] = (
            f"Successfully pushed {action} values for {website_id} to GitHub"
        )

        return result

    def setup_git_config(self) -> tuple[bool, str]:
        """Setup basic git configuration if not already set."""
        commands = [
            ["config", "user.name", "Website IDP Backend"],
            ["config", "user.email", "idp@naserraoofi.com"],
            ["config", "core.autocrlf", "false"],
        ]

        for cmd in commands:
            success, output = self.git_command(cmd)
            if not success:
                return False, f"Failed to set git config: {output}"

        return True, "Git configuration completed successfully"

    # --- Directory Watcher Logic ---
    def _scan_values_dir(self) -> list[str]:
        """Return list of current values yaml files."""
        if not self.values_dir.exists():
            return []
        return [f.name for f in self.values_dir.glob("values-*.yaml") if f.is_file()]

    def _detect_new_files(self) -> list[str]:
        """Detect newly created values files since last scan."""
        current = set(self._scan_values_dir())
        new_files = [f for f in current if f not in self._known_files]
        self._known_files = current
        return new_files

    def _watch_loop(self, interval: float = 2.0):
        """Poll directory for new values files and auto push them."""
        print("[GitHubService] Watcher started for values directory")
        # Initialize known files on start
        self._known_files = set(self._scan_values_dir())
        while not self._stop_event.is_set():
            try:
                new_files = self._detect_new_files()
                if new_files:
                    for filename in new_files:
                        website_id = filename.removeprefix("values-").removesuffix(
                            ".yaml"
                        )
                        print(
                            "[GitHubService] Detected new values file '"
                            f"{filename}' pushing to repo..."
                        )
                        push_result = self.auto_push_values(website_id, "created")
                        if push_result.get("success"):
                            print(
                                "[GitHubService] Auto-push success for '"
                                f"{website_id}': {push_result.get('message')}"
                            )
                        else:
                            print(
                                "[GitHubService] Auto-push failed for '"
                                f"{website_id}': {push_result.get('message')}"
                            )
            except Exception as e:
                print(f"[GitHubService] Watcher error: {e}")
            time.sleep(interval)
        print("[GitHubService] Watcher stopped")

    def start_watcher(self):
        """Start the background watcher thread if not already running."""
        if self._watcher_thread and self._watcher_thread.is_alive():
            return
        self._stop_event.clear()
        self._watcher_thread = threading.Thread(
            target=self._watch_loop, name="values-dir-watcher", daemon=True
        )
        self._watcher_thread.start()

    def stop_watcher(self):
        """Stop the background watcher thread."""
        if not self._watcher_thread:
            return
        self._stop_event.set()
        self._watcher_thread.join(timeout=5)
        self._watcher_thread = None


# Create singleton instance
github_service = GitHubService()
